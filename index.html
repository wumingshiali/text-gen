<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÊñáÂ≠óÊ∏≤ÊüìÂô®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', 'Segoe UI Web (West European)', -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            background: #f3f3f3;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            color: #1f1f1f;
        }

        .container {
            display: flex;
            flex: 1;
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
            gap: 12px;
            padding: 12px;
        }

        /* Â∑¶‰æßÂàóË°®Âå∫Âüü */
        .left-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .panel-title {
            padding: 16px 20px;
            background: rgba(255, 255, 255, 0.8);
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
            color: #1f1f1f;
            font-size: 15px;
            font-weight: 600;
        }

        .text-input-area {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .input-item {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }

        .input-item-number {
            width: 32px;
            height: 32px;
            background: #0078d4;
            color: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            flex-shrink: 0;
            font-size: 13px;
        }

        .input-item input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.13);
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s ease-out;
            background: rgba(255, 255, 255, 0.98);
            font-family: inherit;
        }

        .input-item input:hover {
            border-color: rgba(0, 0, 0, 0.16);
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .input-item input:focus {
            outline: none;
            border-color: #0078d4;
            background: white;
            box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2);
        }

        .input-item button {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.06);
            color: #1f1f1f;
            border: 1px solid rgba(0, 0, 0, 0.13);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease-out;
            font-size: 13px;
            font-family: inherit;
        }

        .input-item button:hover {
            background: rgba(0, 0, 0, 0.09);
            border-color: rgba(0, 0, 0, 0.16);
        }

        .input-item button:active {
            background: rgba(0, 0, 0, 0.12);
        }

        .add-btn {
            width: 100%;
            padding: 8px;
            background: #0078d4;
            color: white;
            border: 1px solid #0078d4;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.15s ease-out;
            margin-top: 8px;
            font-family: inherit;
        }

        .add-btn:hover {
            background: #1084d7;
            border-color: #1084d7;
        }

        .add-btn:active {
            background: #0066b2;
            border-color: #0066b2;
        }

        /* Âè≥‰æßÈÄâÈ°πÂå∫Âüü */
        .right-panel {
            width: 280px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.06);
            border-radius: 8px;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .option-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .option-label {
            font-weight: 500;
            color: #1f1f1f;
            font-size: 13px;
        }

        .font-select-wrapper {
            position: relative;
        }

        .font-search {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.13);
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s ease-out;
            background: rgba(255, 255, 255, 0.98);
            font-family: inherit;
            color: #1f1f1f;
        }

        .font-search:hover {
            border-color: rgba(0, 0, 0, 0.16);
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .font-search:focus {
            outline: none;
            border-color: #0078d4;
            background: white;
            box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2);
        }

        .font-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.13);
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .font-dropdown.show {
            display: block;
        }

        .font-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.1s;
        }

        .font-option:hover {
            background: rgba(0, 120, 212, 0.1);
        }

        .font-option.selected {
            background: rgba(0, 120, 212, 0.2);
        }

        /* ÈÄöÁî®‰∏ãÊãâÊ°ÜÊ†∑Âºè */
        .select-wrapper {
            position: relative;
        }

        .select-input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid rgba(0, 0, 0, 0.13);
            border-radius: 6px;
            font-size: 13px;
            transition: all 0.2s ease-out;
            background: rgba(255, 255, 255, 0.98);
            font-family: inherit;
            color: #1f1f1f;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .select-input:hover {
            border-color: rgba(0, 0, 0, 0.16);
            background: white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .select-input:focus {
            outline: none;
            border-color: #0078d4;
            background: white;
            box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2);
        }

        .select-arrow {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-right: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            transform: rotate(45deg);
            margin-left: 8px;
            transition: transform 0.15s;
        }

        .select-wrapper.open .select-arrow {
            transform: rotate(-135deg);
        }

        .select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid rgba(0, 0, 0, 0.13);
            border-top: none;
            border-radius: 0 0 4px 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .select-dropdown.show {
            display: block;
        }

        .select-option {
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.1s;
        }

        .select-option:hover {
            background: rgba(0, 120, 212, 0.1);
        }

        .select-option.selected {
            background: rgba(0, 120, 212, 0.2);
            color: #0078d4;
            font-weight: 500;
        }

        /* ‰∏ãÊñπÊåâÈíÆÂå∫Âüü */
        .footer {
            padding: 12px 20px;
            display: flex;
            justify-content: center;
            gap: 12px;
            background: rgba(255, 255, 255, 0.6);
            border-top: 1px solid rgba(0, 0, 0, 0.06);
        }

        .render-btn {
            padding: 10px 36px;
            background: #0078d4;
            color: white;
            border: 1px solid #0078d4;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease-out;
            font-family: inherit;
        }

        .render-btn:hover:not(:disabled) {
            background: #1084d7;
            border-color: #1084d7;
        }

        .render-btn:active:not(:disabled) {
            background: #0066b2;
            border-color: #0066b2;
        }

        .render-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .download-btn {
            padding: 10px 36px;
            background: #107c10;
            color: white;
            border: 1px solid #107c10;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease-out;
            display: none;
            font-family: inherit;
        }

        .download-btn:hover {
            background: #128012;
            border-color: #128012;
        }

        .download-btn:active {
            background: #0c5a0c;
            border-color: #0c5a0c;
        }

        /* ËøõÂ∫¶Êù° */
        .progress-container {
            width: 300px;
            display: none;
            flex-direction: column;
            gap: 8px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(0, 0, 0, 0.13);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0078d4;
            width: 0%;
            transition: width 0.2s ease-out;
            border-radius: 2px;
        }

        .progress-text {
            color: white;
            font-size: 13px;
            text-align: center;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* ÂìçÂ∫îÂºè */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }

            .right-panel {
                width: 100%;
            }
        }

        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.13);
            border-radius: 6px;
            border: 3px solid transparent;
            background-clip: content-box;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.16);
            border: 3px solid transparent;
            background-clip: content-box;
        }

        input[type="number"] {
            width: 100% !important;
            padding: 8px 12px !important;
            border: 1px solid rgba(0, 0, 0, 0.13) !important;
            border-radius: 6px !important;
            font-size: 13px !important;
            transition: all 0.2s ease-out !important;
            background: rgba(255, 255, 255, 0.98) !important;
            font-family: inherit !important;
            color: #1f1f1f !important;
        }

        input[type="number"]:hover {
            border-color: rgba(0, 0, 0, 0.16) !important;
            background: white !important;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08) !important;
        }

        input[type="number"]:focus {
            outline: none !important;
            border-color: #0078d4 !important;
            background: white !important;
            box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2) !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Â∑¶‰æßÔºöÊñáÂ≠óËæìÂÖ•ÂàóË°® -->
        <div class="left-panel">
            <div class="panel-title">ÊñáÂ≠óÂàóË°®</div>
            <div class="text-input-area" id="textList">
                <div class="input-item">
                    <div class="input-item-number">1</div>
                    <input type="text" placeholder="ËæìÂÖ•Ë¶ÅÊ∏≤ÊüìÁöÑÊñáÂ≠ó..." value="">
                    <button onclick="removeItem(this)">Âà†Èô§</button>
                </div>
            </div>
            <div style="padding: 12px;">
                <button class="add-btn" onclick="addItem()">Ê∑ªÂä†Êñ∞È°π</button>
            </div>
        </div>

        <!-- Âè≥‰æßÔºöÈÄâÈ°πÈù¢Êùø -->
        <div class="right-panel">
            <div class="option-group">
                <label class="option-label">Â≠ó‰Ωì</label>
                <div style="display: flex; gap: 6px;">
                    <div class="font-select-wrapper" style="flex: 1;">
                        <input type="text" class="font-search" id="fontSearch" placeholder="ÊêúÁ¥¢ÊàñËæìÂÖ•Â≠ó‰ΩìÂêç...">
                        <div class="font-dropdown" id="fontDropdown"></div>
                    </div>
                    <button style="padding: 8px 12px; background: #0078d4; color: white; border: 1px solid #0078d4; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.15s; font-family: inherit;" onclick="addCustomFont()" title="Ê∑ªÂä†Ëá™ÂÆö‰πâÂ≠ó‰Ωì">+</button>
                    <button style="padding: 8px 12px; background: #0078d4; color: white; border: 1px solid #0078d4; border-radius: 4px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.15s; font-family: inherit;" onclick="document.getElementById('fontFileInput').click()" title="‰∏ä‰º†Â≠ó‰ΩìÊñá‰ª∂">üìÅ</button>
                    <input type="file" id="fontFileInput" accept=".ttf,.otf,.woff,.woff2" style="display: none;" onchange="uploadFontFile(event)">
                </div>
                <input type="hidden" id="fontFamily" value="">
            </div>

            <div class="option-group">
                <label class="option-label">Â≠óÂè∑</label>
                <input type="number" id="fontSize" min="12" max="300" value="48" step="1">
            </div>

            <div class="option-group">
                <label class="option-label">ËæìÂá∫Ê†ºÂºè</label>
                <div class="select-wrapper" id="formatWrapper">
                    <div class="select-input" id="formatInput">WebP (Êé®Ëçê)<span class="select-arrow"></span></div>
                    <div class="select-dropdown" id="formatDropdown"></div>
                </div>
                <input type="hidden" id="format" value="webp">
            </div>
        </div>
    </div>

    <!-- ‰∏ãÊñπÔºöÊìç‰ΩúÊåâÈíÆÂå∫Âüü -->
    <div class="footer">
        <button class="render-btn" id="renderBtn" onclick="startRender()">ÂºÄÂßãÊ∏≤Êüì</button>
        <button class="download-btn" id="downloadBtn" onclick="downloadZip()">‰∏ãËΩΩ ZIP</button>
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">ÂáÜÂ§á‰∏≠...</div>
        </div>
    </div>

    <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
    <script>
        // FontDetector Á±ª - Ê£ÄÊµãÁ≥ªÁªüÂ≠ó‰Ωì
        class FontDetector {
            constructor() {
                this.fonts = [];
            }

            async detectSystemFonts() {
                console.log('üìù ÂºÄÂßãÊ£ÄÊµãÁ≥ªÁªüÂ≠ó‰Ωì...');
                
                // Ê£ÄÊü•ÊµèËßàÂô®ÊòØÂê¶ÊîØÊåÅ queryLocalFonts API
                if (!window.queryLocalFonts) {
                    console.log('‚ö†Ô∏è ÊµèËßàÂô®‰∏çÊîØÊåÅ queryLocalFonts API');
                    console.log('üí° ÊèêÁ§∫: ËØ∑ÈÄöËøá‰∏ä‰º†Â≠ó‰ΩìÊñá‰ª∂ÊàñËæìÂÖ•Ëá™ÂÆö‰πâÂ≠ó‰ΩìÂêçÊù•‰ΩøÁî®');
                    this.fonts = [];
                    return;
                }
                
                try {
                    console.log('üîç ‰ΩøÁî® queryLocalFonts() Ê£ÄÊµãÁ≥ªÁªüÂ≠ó‰Ωì...');
                    // ËØ∑Ê±ÇËé∑ÂèñÁ≥ªÁªüÂ≠ó‰ΩìÊùÉÈôê
                    const availableFonts = await window.queryLocalFonts();
                    console.log('‚úÖ queryLocalFonts() ËøîÂõûÁöÑÂ≠ó‰ΩìÊï∞:', availableFonts.length);
                    
                    // ÊèêÂèñÂ≠ó‰ΩìÊóèÂêçÂπ∂ÂéªÈáç
                    const fontFamilies = new Set();
                    availableFonts.forEach(font => {
                        const family = font.family;
                        if (family && !fontFamilies.has(family)) {
                            fontFamilies.add(family);
                            console.log('‚úì Ê£ÄÊµãÂà∞Â≠ó‰Ωì:', family);
                        }
                    });
                    
                    this.fonts = Array.from(fontFamilies).sort();
                } catch (error) {
                    console.log('‚ùå queryLocalFonts() Âá∫Èîô:', error.message);
                    console.log('üí° ÂèØËÉΩÂéüÂõ†: Áî®Êà∑ÊãíÁªùÊùÉÈôêÊàñÊµèËßàÂô®‰∏çÊîØÊåÅ');
                    this.fonts = [];
                }
                
                console.log('=== Ê£ÄÊµãÂÆåÊàê ===');
                console.log('Ê£ÄÊµãÂà∞ÁöÑÂ≠ó‰Ωì:', this.fonts);
                console.log('Â≠ó‰ΩìÊï∞Èáè:', this.fonts.length);
            }

            getFonts() {
                return this.fonts;
            }
        }

        const fontDetector = new FontDetector();

        let renderedFiles = []; // Â≠òÂÇ®ÁîüÊàêÁöÑÊñá‰ª∂
        let availableFonts = []; // Â≠òÂÇ®Ê£ÄÊµãÂà∞ÁöÑÂèØÁî®Â≠ó‰Ωì

        // Ê£ÄÊµãÁ≥ªÁªü‰∏≠ÂèØÁî®ÁöÑÂ≠ó‰Ωì
        async function detectAvailableFonts() {
            console.log('üîç ÂºÄÂßãÊ£ÄÊµãÂèØÁî®Â≠ó‰Ωì...');
            await fontDetector.detectSystemFonts();
            availableFonts = fontDetector.getFonts();
            console.log('‚úÖ Ëé∑ÂèñÂà∞Â≠ó‰ΩìÂàóË°®:', availableFonts);
            console.log('üìä Â≠ó‰ΩìÊÄªÊï∞:', availableFonts.length);
            updateFontSelect();
        }

        // Êõ¥Êñ∞Â≠ó‰ΩìÈÄâÊã©‰∏ãÊãâÂàóË°®
        function updateFontSelect() {
            const fontSearch = document.getElementById('fontSearch');
            const fontDropdown = document.getElementById('fontDropdown');
            const fontFamily = document.getElementById('fontFamily');
            
            fontDropdown.innerHTML = '';

            if (availableFonts.length === 0) {
                fontSearch.placeholder = 'Êó†ÂèØÁî®Â≠ó‰ΩìÊàñËæìÂÖ•Ëá™ÂÆö‰πâÂ≠ó‰ΩìÂêç...';
                fontFamily.value = '';
                fontSearch.value = '';
                return;
            }

            availableFonts.forEach(font => {
                const option = document.createElement('div');
                option.className = 'font-option';
                option.textContent = font;
                option.style.fontFamily = `"${font}", sans-serif`;
                option.dataset.font = font;
                
                option.addEventListener('click', () => {
                    fontFamily.value = font;
                    fontSearch.value = font;
                    fontDropdown.classList.remove('show');
                });
                
                fontDropdown.appendChild(option);
            });

            // ËÆæÁΩÆÈªòËÆ§ÈÄâÊã©
            let selectedFont = availableFonts[0];
            
            fontFamily.value = selectedFont;
            fontSearch.value = selectedFont;
        }

        // ÊêúÁ¥¢Â≠ó‰Ωì
        function searchFonts(query) {
            const fontDropdown = document.getElementById('fontDropdown');
            const fontOptions = fontDropdown.querySelectorAll('.font-option');
            const lowerQuery = query.toLowerCase();
            let hasMatch = false;

            fontOptions.forEach(option => {
                const fontName = option.dataset.font;
                if (fontName.toLowerCase().includes(lowerQuery)) {
                    option.style.display = 'block';
                    hasMatch = true;
                } else {
                    option.style.display = 'none';
                }
            });

            return hasMatch;
        }

        // Ê∑ªÂä†Ëá™ÂÆö‰πâÂ≠ó‰Ωì
        function addCustomFont() {
            const fontSearch = document.getElementById('fontSearch');
            const customFont = fontSearch.value.trim();

            if (!customFont) {
                alert('ËØ∑ËæìÂÖ•Â≠ó‰ΩìÂêçÁß∞');
                return;
            }

            // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
            if (availableFonts.includes(customFont)) {
                alert('ËØ•Â≠ó‰ΩìÂ∑≤Â≠òÂú®');
                fontSearch.value = customFont;
                return;
            }

            // Ê∑ªÂä†Âà∞ÂàóË°®
            availableFonts.push(customFont);
            availableFonts.sort();

            // Êõ¥Êñ∞‰∏ãÊãâÊ°Ü
            updateFontSelect();

            // ËÆæÁΩÆ‰∏∫ÂΩìÂâçÈÄâ‰∏≠
            document.getElementById('fontFamily').value = customFont;
            fontSearch.value = customFont;

            console.log(`‚úì Â∑≤Ê∑ªÂä†Ëá™ÂÆö‰πâÂ≠ó‰Ωì: ${customFont}`);
            alert(`‚úì Â∑≤Ê∑ªÂä†Â≠ó‰Ωì: ${customFont}`);
        }

        // ‰∏ä‰º†Â≠ó‰ΩìÊñá‰ª∂
        function uploadFontFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const fontData = e.target.result;
                const fontName = file.name.split('.')[0]; // Ëé∑ÂèñÊñá‰ª∂Âêç‰Ωú‰∏∫Â≠ó‰ΩìÂêç
                
                // ÂàõÂª∫ @font-face
                const style = document.createElement('style');
                const fontUrl = URL.createObjectURL(new Blob([fontData], { type: file.type }));
                
                let fontFace = `@font-face {
                    font-family: "${fontName}";
                    src: url('${fontUrl}');
                }`;
                
                style.textContent = fontFace;
                document.head.appendChild(style);

                // Ê∑ªÂä†Âà∞Â≠ó‰ΩìÂàóË°®
                if (!availableFonts.includes(fontName)) {
                    availableFonts.push(fontName);
                    availableFonts.sort();
                    updateFontSelect();
                }

                // ËÆæÁΩÆ‰∏∫ÂΩìÂâçÈÄâ‰∏≠
                document.getElementById('fontFamily').value = fontName;
                document.getElementById('fontSearch').value = fontName;

                console.log(`‚úì Â∑≤Âä†ËΩΩÂ≠ó‰ΩìÊñá‰ª∂: ${fontName}`);
                alert(`‚úì Â∑≤Âä†ËΩΩÂ≠ó‰Ωì: ${fontName}`);
            };

            reader.readAsArrayBuffer(file);
        }

        // È°µÈù¢Âä†ËΩΩÊó∂Ê£ÄÊµãÂ≠ó‰Ωì
        window.addEventListener('load', () => {
            // ‰∏çÂú®È°µÈù¢Âä†ËΩΩÊó∂Ëá™Âä®Ê£ÄÊµãÔºåÈúÄË¶ÅÁî®Êà∑‰∫§‰∫í
            initFormatSelect();
            
            const fontSearch = document.getElementById('fontSearch');
            const fontDropdown = document.getElementById('fontDropdown');
            const fontFamily = document.getElementById('fontFamily');
            let fontDetected = false; // Ê†áËÆ∞ÊòØÂê¶Â∑≤Ê£ÄÊµãËøáÂ≠ó‰Ωì

            // È¶ñÊ¨°ÁÇπÂáªÂ≠ó‰ΩìÊêúÁ¥¢Ê°ÜÊó∂Ê£ÄÊµãÁ≥ªÁªüÂ≠ó‰Ωì
            fontSearch.addEventListener('click', async (e) => {
                if (!fontDetected) {
                    fontDetected = true;
                    fontSearch.placeholder = '‚è≥ Ê£ÄÊµãÁ≥ªÁªüÂ≠ó‰Ωì‰∏≠...';
                    await detectAvailableFonts();
                    if (availableFonts.length === 0) {
                        fontSearch.placeholder = 'Êó†ÂèØÁî®Â≠ó‰ΩìÊàñËæìÂÖ•Ëá™ÂÆö‰πâÂ≠ó‰ΩìÂêç...';
                    }
                }
                
                // ÊòæÁ§∫‰∏ãÊãâÂàóË°®
                if (availableFonts.length > 0) {
                    const fontOptions = fontDropdown.querySelectorAll('.font-option');
                    fontOptions.forEach(option => {
                        option.style.display = 'block';
                    });
                    fontDropdown.classList.add('show');
                }
            });

            // ÊêúÁ¥¢ËæìÂÖ•
            fontSearch.addEventListener('input', (e) => {
                const query = e.target.value;
                if (query.trim()) {
                    searchFonts(query);
                    fontDropdown.classList.add('show');
                } else {
                    fontDropdown.classList.remove('show');
                }
            });

            // ÁÇπÂáªÊêúÁ¥¢Ê°ÜÊòæÁ§∫‰∏ãÊãâÂàóË°®
            fontSearch.addEventListener('focus', () => {
                if (fontSearch.value.trim() && availableFonts.length > 0) {
                    fontDropdown.classList.add('show');
                }
            });

            // ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠‰∏ãÊãâÂàóË°®
            document.addEventListener('click', (e) => {
                if (!fontSearch.contains(e.target) && !fontDropdown.contains(e.target)) {
                    fontDropdown.classList.remove('show');
                }
            });
        });

        // ÂàùÂßãÂåñËæìÂá∫Ê†ºÂºèÈÄâÊã©Ê°Ü
        function initFormatSelect() {
            const formatOptions = [
                { value: 'webp', label: 'WebP (Êé®Ëçê)' },
                { value: 'avif', label: 'AVIF' },
                { value: 'png', label: 'PNG' },
                { value: 'jpg', label: 'JPG' },
                { value: 'gif', label: 'GIF' },
                { value: 'svg', label: 'SVG' }
            ];

            const formatWrapper = document.getElementById('formatWrapper');
            const formatInput = document.getElementById('formatInput');
            const formatDropdown = document.getElementById('formatDropdown');
            const formatHidden = document.getElementById('format');

            // ÂàõÂª∫‰∏ãÊãâÈÄâÈ°π
            formatOptions.forEach(opt => {
                const option = document.createElement('div');
                option.className = 'select-option';
                option.textContent = opt.label;
                option.dataset.value = opt.value;

                if (opt.value === 'webp') {
                    option.classList.add('selected');
                }

                option.addEventListener('click', () => {
                    formatHidden.value = opt.value;
                    formatInput.innerHTML = opt.label + '<span class="select-arrow"></span>';
                    formatDropdown.classList.remove('show');
                    
                    // Êõ¥Êñ∞ÈÄâ‰∏≠Áä∂ÊÄÅ
                    const allOptions = formatDropdown.querySelectorAll('.select-option');
                    allOptions.forEach(o => o.classList.remove('selected'));
                    option.classList.add('selected');
                });

                formatDropdown.appendChild(option);
            });

            // ÁÇπÂáªËæìÂÖ•Ê°ÜÂàáÊç¢‰∏ãÊãâÊ°Ü
            formatInput.addEventListener('click', () => {
                formatWrapper.classList.toggle('open');
                formatDropdown.classList.toggle('show');
            });

            // ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠
            document.addEventListener('click', (e) => {
                if (!formatWrapper.contains(e.target)) {
                    formatWrapper.classList.remove('open');
                    formatDropdown.classList.remove('show');
                }
            });
        }

        // Ê∑ªÂä†Êñ∞È°πÁõÆ
        function addItem() {
            const textList = document.getElementById('textList');
            const itemCount = textList.children.length;
            const newItem = document.createElement('div');
            newItem.className = 'input-item';
            newItem.innerHTML = `
                <div class="input-item-number">${itemCount + 1}</div>
                <input type="text" placeholder="ËæìÂÖ•Ë¶ÅÊ∏≤ÊüìÁöÑÊñáÂ≠ó...">
                <button onclick="removeItem(this)">Âà†Èô§</button>
            `;
            textList.appendChild(newItem);
            updateNumbers();
        }

        // Âà†Èô§È°πÁõÆ
        function removeItem(btn) {
            const textList = document.getElementById('textList');
            if (textList.children.length > 1) {
                btn.parentElement.remove();
                updateNumbers();
            } else {
                alert('Ëá≥Â∞ëÈúÄË¶Å‰øùÁïô‰∏ÄÈ°πÔºÅ');
            }
        }

        // Êõ¥Êñ∞Â∫èÂè∑
        function updateNumbers() {
            const textList = document.getElementById('textList');
            Array.from(textList.children).forEach((item, index) => {
                item.querySelector('.input-item-number').textContent = index + 1;
            });
        }

        // Ëé∑ÂèñÊâÄÊúâËæìÂÖ•ÁöÑÊñáÂ≠ó
        function getTextItems() {
            const textList = document.getElementById('textList');
            return Array.from(textList.querySelectorAll('input')).map(input => input.value).filter(text => text.trim());
        }

        // ÂºÄÂßãÊ∏≤Êüì
        async function startRender() {
            const textItems = getTextItems();
            if (textItems.length === 0) {
                alert('ËØ∑Ëá≥Â∞ëËæìÂÖ•‰∏ÄÈ°πÊñáÂ≠óÔºÅ');
                return;
            }

            let fontFamily = document.getElementById('fontFamily').value;
            const fontSearch = document.getElementById('fontSearch').value;
            
            // Â¶ÇÊûúfontFamily‰∏∫Á©∫Ôºå‰ΩøÁî®ÊêúÁ¥¢Ê°ÜÁöÑÂÄº
            if (!fontFamily || fontFamily === 'undefined') {
                fontFamily = fontSearch.trim();
            }
            
            if (!fontFamily) {
                alert('ËØ∑ÈÄâÊã©ÊàñËæìÂÖ•Â≠ó‰ΩìÔºÅ');
                return;
            }

            const fontSize = parseInt(document.getElementById('fontSize').value);
            const format = document.getElementById('format').value;

            // ÊòæÁ§∫ËøõÂ∫¶Êù°
            const progressContainer = document.getElementById('progressContainer');
            const renderBtn = document.getElementById('renderBtn');
            const downloadBtn = document.getElementById('downloadBtn');
            
            progressContainer.style.display = 'flex';
            renderBtn.disabled = true;
            downloadBtn.style.display = 'none';
            renderedFiles = [];

            try {
                // Á¨¨‰∏ÄÊ≠•ÔºöÊ∏≤ÊüìÊâÄÊúâÊñá‰ª∂
                for (let i = 0; i < textItems.length; i++) {
                    const progress = Math.round((i / textItems.length) * 50); // 0-50%
                    updateProgress(progress, `Ê∏≤Êüì‰∏≠: ${i + 1}/${textItems.length}`);
                    
                    const canvas = createTextCanvas(textItems[i], fontFamily, fontSize);
                    const fileData = await canvasToFile(canvas, format);
                    
                    renderedFiles.push({
                        name: `${String(i + 1).padStart(3, '0')}.${format}`,
                        data: fileData
                    });
                    
                    await sleep(100); // ÁªôUIÊõ¥Êñ∞ÁöÑÊó∂Èó¥
                }

                // Á¨¨‰∫åÊ≠•ÔºöÂéãÁº©ÊâÄÊúâÊñá‰ª∂
                updateProgress(50, 'ÂéãÁº©Êñá‰ª∂‰∏≠...');
                await sleep(200);
                
                for (let i = 0; i < renderedFiles.length; i++) {
                    const progress = 50 + Math.round((i / renderedFiles.length) * 50); // 50-100%
                    updateProgress(progress, `ÂéãÁº©‰∏≠: ${i + 1}/${renderedFiles.length}`);
                    
                    const compressedData = await compressImage(renderedFiles[i].data, format);
                    renderedFiles[i].data = compressedData;
                    
                    await sleep(50);
                }

                updateProgress(100, 'Ê∏≤ÊüìÂÆåÊàêÔºÅ');
                await sleep(500);

                // ÈöêËóèËøõÂ∫¶Êù°ÔºåÊòæÁ§∫‰∏ãËΩΩÊåâÈíÆ
                progressContainer.style.display = 'none';
                downloadBtn.style.display = 'block';
                renderBtn.disabled = false;
            } catch (error) {
                console.error('Ê∏≤ÊüìÈîôËØØ:', error);
                alert('Ê∏≤ÊüìÂá∫Èîô: ' + error.message);
                progressContainer.style.display = 'none';
                renderBtn.disabled = false;
            }
        }

        // ÂàõÂª∫ÊñáÂ≠óÁîªÂ∏É
        function createTextCanvas(text, fontFamily, fontSize) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d', { willReadFrequently: true });

            // ËÆæÁΩÆÂ≠ó‰ΩìÂπ∂ÊµãÈáèÊñáÂ≠óÂÆΩÂ∫¶
            ctx.font = `bold ${fontSize}px "${fontFamily}", Arial, sans-serif`;
            ctx.textBaseline = 'top';
            
            const metrics = ctx.measureText(text);
            let textWidth = metrics.width;
            const textHeight = fontSize * 1.5;

            // ËÆæÁΩÆÁîªÂ∏ÉÂ§ßÂ∞èÔºàÊ∑ªÂä†ÂÜÖËæπË∑ùÔºâ
            const padding = fontSize * 0.3;
            canvas.width = Math.max(textWidth + padding * 2, 100);
            canvas.height = Math.max(textHeight + padding * 2, 50);

            // ÈáçÊñ∞Ëé∑Âèñ contextÔºàË∞ÉÊï¥Â§ßÂ∞èÂêéÈúÄË¶ÅÈáçÊñ∞ËÆæÁΩÆÂ≠ó‰ΩìÔºâ
            const ctx2 = canvas.getContext('2d', { willReadFrequently: true, alpha: true });

            // ËÉåÊôØ‰øùÊåÅÈÄèÊòéÔºà‰∏çÁªòÂà∂ËÉåÊôØÔºâ

            // ÁªòÂà∂ÊñáÂ≠ó
            ctx2.fillStyle = '#000000';
            ctx2.font = `bold ${fontSize}px "${fontFamily}", Arial, sans-serif`;
            ctx2.textBaseline = 'top';
            ctx2.antialias = 'subpixel';
            ctx2.fillText(text, padding, padding);

            return canvas;
        }

        // Canvas ËΩ¨Êñá‰ª∂
        async function canvasToFile(canvas, format) {
            // SVG Ê†ºÂºèÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ
            if (format === 'svg') {
                const width = canvas.width;
                const height = canvas.height;
                const dataURL = canvas.toDataURL('image/png');
                
                const svgContent = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><image width="${width}" height="${height}" xlink:href="${dataURL}"/></svg>`;
                return new Blob([svgContent], { type: 'image/svg+xml' });
            }
            
            return new Promise((resolve, reject) => {
                // ÂÖ∂‰ªñÊ†ºÂºèÈÉΩ‰ΩøÁî®ÊúÄÈ´òË¥®Èáè
                let mimeType;
                let quality = 1.0;
                
                if (format === 'jpg') {
                    mimeType = 'image/jpeg';
                } else if (format === 'avif') {
                    mimeType = 'image/avif';
                } else if (format === 'gif') {
                    mimeType = 'image/gif';
                } else {
                    mimeType = `image/${format}`;
                }
                
                canvas.toBlob(
                    blob => {
                        if (!blob) {
                            // Â¶ÇÊûúÊµèËßàÂô®‰∏çÊîØÊåÅËØ•Ê†ºÂºèÔºåÈôçÁ∫ßÂà∞ PNG
                            canvas.toBlob(
                                pngBlob => resolve(pngBlob),
                                'image/png',
                                quality
                            );
                        } else {
                            resolve(blob);
                        }
                    },
                    mimeType,
                    quality
                );
            });
        }

        // Êó†ÊçüÂéãÁº©ÂõæÁâáÊñá‰ª∂
        async function compressImage(blob, format) {
            // WebP ‰ΩøÁî®Êó†ÊçüÊ®°Âºè
            if (format === 'webp') {
                const canvas = await createCanvasFromBlob(blob);
                return new Promise((resolve) => {
                    canvas.toBlob(
                        compressedBlob => resolve(compressedBlob),
                        'image/webp'
                    );
                });
            }
            
            // AVIF ‰ΩøÁî®Êó†ÊçüÊ®°Âºè
            if (format === 'avif') {
                const canvas = await createCanvasFromBlob(blob);
                return new Promise((resolve) => {
                    canvas.toBlob(
                        compressedBlob => {
                            // Â¶ÇÊûúÊµèËßàÂô®‰∏çÊîØÊåÅ AVIFÔºåÈôçÁ∫ßÂà∞ PNG
                            if (!compressedBlob) {
                                canvas.toBlob(
                                    pngBlob => resolve(pngBlob),
                                    'image/png'
                                );
                            } else {
                                resolve(compressedBlob);
                            }
                        },
                        'image/avif'
                    );
                });
            }
            
            // PNG Êú¨Ë∫´Â∞±ÊòØÊó†ÊçüÊ†ºÂºèÔºåÈÄöËøáÈáçÊñ∞ÁºñÁ†ÅÊù•‰ºòÂåñ
            if (format === 'png') {
                const canvas = await createCanvasFromBlob(blob);
                return new Promise((resolve) => {
                    canvas.toBlob(
                        compressedBlob => resolve(compressedBlob),
                        'image/png'
                    );
                });
            }
            
            // JPG ‰ΩøÁî®ÊúÄÈ´òË¥®ÈáèÁöÑÁºñÁ†ÅÔºàÊó†ÊçüÔºâ
            if (format === 'jpg') {
                const canvas = await createCanvasFromBlob(blob);
                return new Promise((resolve) => {
                    canvas.toBlob(
                        compressedBlob => resolve(compressedBlob),
                        'image/jpeg',
                        1.0
                    );
                });
            }
            
            // GIF Êó†ÊçüÊ†ºÂºèÔºåÈÄöËøáÈáçÊñ∞ÁºñÁ†Å‰ºòÂåñ
            if (format === 'gif') {
                const canvas = await createCanvasFromBlob(blob);
                return new Promise((resolve) => {
                    canvas.toBlob(
                        compressedBlob => resolve(compressedBlob),
                        'image/gif'
                    );
                });
            }
            
            // SVG Êó†ÈúÄÂéãÁº©ÔºåÁõ¥Êé•ËøîÂõû
            if (format === 'svg') {
                return blob;
            }
            
            return blob;
        }

        // ‰ªé Blob ÂàõÂª∫ Canvas
        function createCanvasFromBlob(blob) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        resolve(canvas);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(blob);
            });
        }

        // Áù°Áú†ÂáΩÊï∞
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Êõ¥Êñ∞ËøõÂ∫¶Êù°
        function updateProgress(percent, text) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressText').textContent = text;
        }

        // ‰∏ãËΩΩ ZIP
        async function downloadZip() {
            if (!window.JSZip) {
                alert('Ê≠£Âú®Âä†ËΩΩÂéãÁº©Â∫ìÔºåËØ∑Á®çÂÄô...');
                await sleep(1000);
                if (!window.JSZip) {
                    alert('ÂéãÁº©Â∫ìÂä†ËΩΩÂ§±Ë¥•');
                    return;
                }
            }

            const downloadBtn = document.getElementById('downloadBtn');
            downloadBtn.disabled = true;
            downloadBtn.textContent = '‚è≥ ÊâìÂåÖ‰∏≠...';

            try {
                const zip = new JSZip();
                
                for (const file of renderedFiles) {
                    zip.file(file.name, file.data);
                }

                const blob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'render.zip';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);

                downloadBtn.textContent = '‚¨áÔ∏è ‰∏ãËΩΩ ZIP';
                downloadBtn.disabled = false;
            } catch (error) {
                console.error('ÊâìÂåÖÈîôËØØ:', error);
                alert('ÊâìÂåÖÂá∫Èîô: ' + error.message);
                downloadBtn.textContent = '‚¨áÔ∏è ‰∏ãËΩΩ ZIP';
                downloadBtn.disabled = false;
            }
        }

        // ÂõûËΩ¶Ê∑ªÂä†
        document.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && e.target.tagName === 'INPUT') {
                addItem();
                e.target.nextElementSibling.nextElementSibling.click();
            }
        });
    </script>
</body>
</html>